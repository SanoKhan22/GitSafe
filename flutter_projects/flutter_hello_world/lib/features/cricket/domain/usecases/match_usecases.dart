import 'package:dartz/dartz.dart';
import 'package:equatable/equatable.dart';
import '../../../../core/error/failure.dart';
import '../../../../core/usecases/usecase.dart';
import '../entities/match_entity.dart';
import '../entities/team_entity.dart';
import '../repositories/cricket_repository.dart';

/// Create Match Use Case
class CreateMatchUseCase implements UseCase<MatchEntity, CreateMatchParams> {
  final CricketRepository repository;

  CreateMatchUseCase({required this.repository});

  @override
  Future<Either<Failure, MatchEntity>> call(CreateMatchParams params) async {
    // Validate match data
    final validationResult = _validateMatchData(params);
    if (validationResult != null) {
      return Left(ValidationFailure(validationResult));
    }

    // Create match entity
    final match = MatchEntity(
      id: '', // Will be generated by repository
      title: params.title,
      description: params.description,
      type: params.type,
      format: params.format,
      status: MatchStatus.scheduled,
      createdAt: DateTime.now(),
      startTime: params.startTime,
      venue: params.venue,
      createdBy: params.createdBy,
      team1: params.team1,
      team2: params.team2,
      totalOvers: params.totalOvers,
      playersPerTeam: params.playersPerTeam,
      rules: params.rules,
    );

    return await repository.createMatch(match);
  }

  String? _validateMatchData(CreateMatchParams params) {
    if (params.title.trim().isEmpty) {
      return 'Match title is required';
    }
    if (params.team1.id == params.team2.id) {
      return 'Teams must be different';
    }
    if (params.totalOvers <= 0) {
      return 'Total overs must be greater than 0';
    }
    if (params.playersPerTeam < 1 || params.playersPerTeam > 11) {
      return 'Players per team must be between 1 and 11';
    }
    if (params.startTime != null && params.startTime!.isBefore(DateTime.now())) {
      return 'Start time cannot be in the past';
    }
    return null;
  }
}

class CreateMatchParams extends Equatable {
  final String title;
  final String description;
  final MatchType type;
  final MatchFormat format;
  final DateTime? startTime;
  final String? venue;
  final String createdBy;
  final TeamEntity team1;
  final TeamEntity team2;
  final int totalOvers;
  final int playersPerTeam;
  final MatchRules rules;

  const CreateMatchParams({
    required this.title,
    required this.description,
    required this.type,
    required this.format,
    this.startTime,
    this.venue,
    required this.createdBy,
    required this.team1,
    required this.team2,
    required this.totalOvers,
    required this.playersPerTeam,
    required this.rules,
  });

  @override
  List<Object?> get props => [
        title,
        type,
        format,
        createdBy,
        team1,
        team2,
        totalOvers,
        playersPerTeam,
      ];
}

/// Get Matches Use Case
class GetMatchesUseCase implements UseCase<List<MatchEntity>, GetMatchesParams> {
  final CricketRepository repository;

  GetMatchesUseCase({required this.repository});

  @override
  Future<Either<Failure, List<MatchEntity>>> call(GetMatchesParams params) async {
    return await repository.getMatches(
      status: params.status,
      userId: params.userId,
      limit: params.limit,
      offset: params.offset,
    );
  }
}

class GetMatchesParams extends Equatable {
  final MatchStatus? status;
  final String? userId;
  final int limit;
  final int offset;

  const GetMatchesParams({
    this.status,
    this.userId,
    this.limit = 20,
    this.offset = 0,
  });

  @override
  List<Object?> get props => [status, userId, limit, offset];
}

/// Get Match By ID Use Case
class GetMatchByIdUseCase implements UseCase<MatchEntity, GetMatchByIdParams> {
  final CricketRepository repository;

  GetMatchByIdUseCase({required this.repository});

  @override
  Future<Either<Failure, MatchEntity>> call(GetMatchByIdParams params) async {
    if (params.matchId.trim().isEmpty) {
      return Left(ValidationFailure('Match ID is required'));
    }

    return await repository.getMatchById(params.matchId);
  }
}

class GetMatchByIdParams extends Equatable {
  final String matchId;

  const GetMatchByIdParams({required this.matchId});

  @override
  List<Object?> get props => [matchId];
}

/// Start Match Use Case
class StartMatchUseCase implements UseCase<MatchEntity, StartMatchParams> {
  final CricketRepository repository;

  StartMatchUseCase({required this.repository});

  @override
  Future<Either<Failure, MatchEntity>> call(StartMatchParams params) async {
    if (params.matchId.trim().isEmpty) {
      return Left(ValidationFailure('Match ID is required'));
    }

    // Get match first to validate it can be started
    final matchResult = await repository.getMatchById(params.matchId);
    
    return matchResult.fold(
      (failure) => Left(failure),
      (match) async {
        // Validate match can be started
        final validationResult = _validateMatchCanStart(match);
        if (validationResult != null) {
          return Left(ValidationFailure(validationResult));
        }

        return await repository.startMatch(params.matchId);
      },
    );
  }

  String? _validateMatchCanStart(MatchEntity match) {
    if (match.status != MatchStatus.scheduled) {
      return 'Match is not in scheduled status';
    }
    if (!match.canStart) {
      return 'Match cannot be started - check team compositions';
    }
    return null;
  }
}

class StartMatchParams extends Equatable {
  final String matchId;

  const StartMatchParams({required this.matchId});

  @override
  List<Object?> get props => [matchId];
}

/// End Match Use Case
class EndMatchUseCase implements UseCase<MatchEntity, EndMatchParams> {
  final CricketRepository repository;

  EndMatchUseCase({required this.repository});

  @override
  Future<Either<Failure, MatchEntity>> call(EndMatchParams params) async {
    if (params.matchId.trim().isEmpty) {
      return Left(ValidationFailure('Match ID is required'));
    }

    return await repository.endMatch(params.matchId, params.result);
  }
}

class EndMatchParams extends Equatable {
  final String matchId;
  final MatchResult result;

  const EndMatchParams({
    required this.matchId,
    required this.result,
  });

  @override
  List<Object?> get props => [matchId, result];
}

/// Get Live Matches Use Case
class GetLiveMatchesUseCase implements UseCase<List<MatchEntity>, NoParams> {
  final CricketRepository repository;

  GetLiveMatchesUseCase({required this.repository});

  @override
  Future<Either<Failure, List<MatchEntity>>> call(NoParams params) async {
    return await repository.getLiveMatches();
  }
}

/// Update Match Use Case
class UpdateMatchUseCase implements UseCase<MatchEntity, UpdateMatchParams> {
  final CricketRepository repository;

  UpdateMatchUseCase({required this.repository});

  @override
  Future<Either<Failure, MatchEntity>> call(UpdateMatchParams params) async {
    // Validate match data
    final validationResult = _validateMatchUpdate(params.match);
    if (validationResult != null) {
      return Left(ValidationFailure(validationResult));
    }

    return await repository.updateMatch(params.match);
  }

  String? _validateMatchUpdate(MatchEntity match) {
    if (match.id.trim().isEmpty) {
      return 'Match ID is required';
    }
    if (match.title.trim().isEmpty) {
      return 'Match title is required';
    }
    if (match.team1.id == match.team2.id) {
      return 'Teams must be different';
    }
    return null;
  }
}

class UpdateMatchParams extends Equatable {
  final MatchEntity match;

  const UpdateMatchParams({required this.match});

  @override
  List<Object?> get props => [match];
}

/// Delete Match Use Case
class DeleteMatchUseCase implements UseCase<void, DeleteMatchParams> {
  final CricketRepository repository;

  DeleteMatchUseCase({required this.repository});

  @override
  Future<Either<Failure, void>> call(DeleteMatchParams params) async {
    if (params.matchId.trim().isEmpty) {
      return Left(ValidationFailure('Match ID is required'));
    }

    // Get match first to validate it can be deleted
    final matchResult = await repository.getMatchById(params.matchId);
    
    return matchResult.fold(
      (failure) => Left(failure),
      (match) async {
        // Validate match can be deleted
        if (match.status == MatchStatus.inProgress) {
          return Left(ValidationFailure('Cannot delete a match in progress'));
        }

        return await repository.deleteMatch(params.matchId);
      },
    );
  }
}

class DeleteMatchParams extends Equatable {
  final String matchId;

  const DeleteMatchParams({required this.matchId});

  @override
  List<Object?> get props => [matchId];
}

/// Validation Failure for cricket operations
class ValidationFailure extends Failure {
  const ValidationFailure(super.message);
}